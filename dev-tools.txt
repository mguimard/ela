```
# Jour 1 : matinée

# Infos basiques
GET /
#     "number": "9.2.1",
# "minimum_wire_compatibility_version": "8.19.0", (peut cohabiter avec)
# "minimum_index_compatibility_version": "8.0.0" (peut lire les données insérées en 8.0.0)

# santé du cluster
GET _cluster/health

# création index
PUT fruits
PUT legumes
PUT voitures

# chasse au gros shards
GET _cat/shards?v&h=index,shard,node,store&s=store:desc

# Répartition de la donnée
GET _cat/allocation?v&h=shards,disk.percent,node

# vérfication des données insérées
GET bank/_count
GET bank/_search

# Jour 1 - après midi

GET _sql
{
    "query": """
    SELECT * FROM "bank"
    """
}

# Création d'un index
GET pizzas
PUT pizzas
{
    "settings": {
        "index.number_of_shards": 3,
        "number_of_replicas": 1
    }
}

# création auto de l'id
POST pizzas/_doc
{
    "name" : "pizza pates",
    "price" : 11.5
}
# maitrise de l'id
PUT pizzas/_doc/12345
{
    "name" : "chorizo",
    "price" : 10
}

# lecture
GET pizzas/_doc/12345
GET pizzas/_source/12345
GET pizzas/_source/123456

# updates
PUT pizzas/_doc/12345
{
    "name" : "chorizo",
    "price" : 11
}
# updates partielles
POST pizzas/_update/12345
{
    "doc": {
        "name" : "Chorizo"
    }
}

POST pizzas/_update/12345
{
   "script": {
    "source": "ctx._source.price += 1;"
   }
}

DELETE pizzas/_doc/12345
DELETE pizzas

GET pizzas/_search

GET pizzas/_search
{
    "query": {
        "term": {
          "price": {
            "value": 11
          }
        }
    }
}

# range < <= > >=
GET pizzas/_search
{
    "query": {
        "range": {
          "price": {
            "gte": 10,
            "lte" : 20
          }
        }
    }
}





# mappings

GET pizzas

POST pizzas/_doc
{
  "name": "saumon",
  "price" : 12.50
}

GET pizzas/_search

# dynamic mapping
POST employes/_doc
{
    "name" : "alice",
    "last_connection" : "2025-11-25T08:00:00",
    "time" : 12.34
}
GET employes/_mapping


GET bank/_mapping


# Analyse
# transformation string -> tableau de tokens
# type text analysé
GET _analyze?filter_path=**.token&format=yaml
{
    "text" : "880 Holmes Lane"
}
# type keyword : non analysé
GET _analyze?filter_path=**.token&format=yaml
{
    "text" : "880 Holmes Lane",
    "analyzer" : "keyword"
}

GET bank/_search



POST factures/_bulk
{"index":{}}
{"code":"FACT-1234-CLIENT-A"}
{"index":{}}
{"code":"FACT-1234-CLIENT-B"}
{"index":{}}
{"code":"FACT-1234-CLIENT-C"}
{"index":{}}
{"code":"FACT-4321-CLIENT-A"}

# json : code : "FACT-1234-CLIENT-A"
# index : code [fact, 1234, client, a]
# index : code.keyword "FACT-1234-CLIENT-A"

# wildcard
GET factures/_search
{
    "query": {
        "wildcard": {
          "code.keyword": {
            "value": "*-????-*"
          }
        }
    }
}

# prefix
GET factures/_search
{
    "query": {
        "prefix": {
          "code.keyword": {
            "value": "FACT-1234"
          }
        }
    }
}

# regex
GET factures/_search
{
    "query": {
        "regexp": {
          "code.keyword": "[A-Z]+-[\\d]+-.*"
        }
    }
}


# match analyse et compare
GET factures/_search
{
    "query": {
        "match": {
          "code.keyword": "FACT-4321-CLIENT-A"
        }
    }
}

# term query, pas d'analyse
GET factures/_search
{
    "query": {
        "term": {
          "code.keyword": {
            "value": "FACT-1234-CLIENT-A"
          }
        }
    }
}


POST test/_doc
{
    "c" : "ABE"
}

GET test/_search
{
    "query": {
        "range": {
          "c.keyword": {
            "gte":"abc"
          }
        }
    }
}


POST web/_doc
{
    "title" : "Le java c'est super",
    "category" : "dev",
    "sponso" : false,
    "published_at" : "2025-01-15T12:00:00"
}

POST web/_doc
{
    "title" : "Venez decouvrire l'ile pradisiaque de Java",
    "category" : "voyage",
    "sponso" : true,
    "published_at" : "2025-03-15T12:00:00"
}

POST web/_doc
{
    "title" : "Il fait un peu trop la Java et ça finit mal, cliquez ici pour lire la suite...",
    "category" : "konbini",
    "sponso" : true,
    "published_at" : "2025-06-15T12:00:00"
}


GET web/_search
{
    "query": {
        "match": {
          "title": "java"
        }
    }
}

# bool query
GET web/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": "java"
          }
        }
      ],
      "must_not": [],
      "should": [
        {
            "term": {
              "category": {
                "value": "dev",
                "boost": 1
              }
            }
        },
        {
            "term": {
              "category": {
                "value": "voyage",
                "boost": 10
              }
            }
        },
        {
            "term": {
              "sponso": {
                "value": true,
                "boost": 20
              }
            }
        }
      ],
      "filter": [
        {
            "range": {
              "published_at": {
                "gte": "2025",
                "lt": "2026"
              }
            }
        }
      ]
    }
  }
}

# -- mappings custom
GET pizzas

# text : analysé => cherchable
# keyword non analysé => cherchable, sortable, aggregatable

PUT pizzas-v2
{
    "mappings": {
        "properties": {
            "name": {
                "type" : "keyword"
            },
            "price" : {
                "type": "float"
            }
        }
    }
}

# réindexation 
POST _reindex
{
    "source": {
        "index" : "pizzas"
    },
    "dest": {
        "index" : "pizzas-v2"
    }
}

GET pizzas-v2/_search
{
    "query": {
        "term": {
          "price": {
            "value": 11.5
          }
        }
    }
}



# Commandes utiles

# Utilisation de filter path
GET bank/_search
GET bank/_search?filter_path=**.firstname

# Version des noeuds
GET _nodes?filter_path=nodes.*.version
# Mémoire des noeuds (bytes)
GET _nodes?filter_path=nodes.*.jvm.mem.heap_max_in_bytes

# Liste index/documents
GET _cat/indices?v&h=index,docs.count&s=docs.count:desc

# ip/ram/cpu
GET _cat/nodes?v&h=name,ip,heap.percent,cpu,master


# type ip
PUT mes-logs
{
  "mappings": {
    "properties": {
      "ip": {
        "type": "ip"
      }
    }
  }
}

POST mes-logs/_doc
{
  "ip" : "192.168.56.10"
}

GET mes-logs/_search
{
  "query": {
    "term": {
      "ip": {
        "value": "192.168.1.1/16"
      }
    }
  }
}













# TP2

# 1. analyze mappings bank
GET bank/_mapping

# 2. création index bank2, mappings optimisés
PUT bank3
{
  "mappings": {
    "dynamic" : false,
    "properties": {
        "account_number" : {
          "type" : "unsigned_long"
        },
        "address" : {
          "type" : "text",
          "fields" : {
            "as_completion" : {
              "type" : "completion"
            }
          }
        },
        "age" : {
          "type":"unsigned_long"
        },
        "balance" : {
          "type" : "float"
        },
        "city" : {
          "type" : "keyword",
          "fields" : {
            "as_completion" : {
              "type" : "completion"
            }
          }
        },
        "email" : {
          "type": "keyword",
          "index" : false
        },
        "employer" : {
          "type" : "keyword"
        },
        "firstname" : {
          "type" : "keyword"
        },
        "gender" : {
          "type" : "keyword"
        },
        "lastname" : {
          "type" : "keyword"
        },
        "state" : {
          "type" : "keyword"
        }
    }
  }
}

# 3. réindexation bank -> bank2
POST _reindex
{
  "source" : {"index" : "bank"},
  "dest" : {"index" : "bank3"} 
}

# 4. analyse de l'espace disque
GET _cat/indices/bank*?v&h=index,store.size

# 5. requêtes

  # Comptes ayant "street" dans le champ adresse (match ou term)

GET bank2/_search
{
  "query": {
    "match": {
      "address": "yo La StrEEt"
    }
  }
}

GET bank2/_search
{
  "query": {
    "term": {
      "address": {
        "value": "street"
      }
    }
  }
}

    # Comptes ayant plus de 25 ans (range)

GET bank2/_search
{
  "query": {
    "range": {
      "age": {
        "gte": 25
      }
    }
  }
}


    # Comptes ayant entre 25000 dollars et 35000 dollars (range)

GET bank2/_search
{
  "query": {
    "range": {
      "balance": {
        "gte": 25000,
        "lte": 35000
      }
    }
  }
}

# Compte dont le prénom est "Rose" à quelques fautes près (fuzzy)
GET bank2/_search?filter_path=**.firstname
{
  "query": {
    "fuzzy": {
      "firstname": {
        "value": "Roes"
      }
    }
  }
}

# Compte dont le prénom commence par "R" (prefix)
GET bank2/_search
{
  "query": {
    "prefix": {
      "firstname": {
        "value": "r",
        "case_insensitive" : true
      }
    }
  }
}

# Compte dont le prénom contient un "E" (wildcard)
GET bank2/_search
{
  "query": {
    "wildcard": {
      "firstname": {
        "value": "*e*",
        "case_insensitive": true
      }
    }
  }
}

# Rechercher les comptes dont l'age est inférieur à 25 ans et le compte en banque supérieur à 25000. Bonus : booster le score des comptes dont le genre est féminin.
GET bank2/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "range": {
            "age": {
              "lte": 25
            }
          }
        },
        {
          "range": {
            "balance": {
              "gte": 25000
            }
          }
        }
      ],
      "should": [
        {
          "term": {
            "gender": {
              "value": "F"
            }
          }
        }
      ]
    }
  }
}

# Réindexation + scripting
DELETE bank-test
POST _reindex
{
  "source": {
    "index": "bank"
  },
  "dest": {
    "index": "bank-test"
  },
  "script": {
    "source": """
      ctx._source.remove('account_number');
      if(ctx._source.balance < 28000)
        ctx._source.balance += 5000;
      """
  }
}

GET bank-test/_search




GET bank/_search
{
  "aggs": {
    "nombre_de_city_uniques": {
      "cardinality": {
        "field" : "city.keyword"
      }
    }
  }
}




POST mes-super-logs/_doc
{
  "ip" : "1.2.3.4",
  "userName1" : "alice",
  "userName2" : "bob",
  "time" : "2025-11-25T08:00:00"
}


POST mes-super-logs/_doc
{
  "server": {
    "ip": "1.2.3.4"
  },
  "user1": {
    "user": {
      "name": "alice"
    }
  },
  "user2": {
    "user": {
      "name": "bob"
    }
  },
  "@timestamp": "2025-11-25T08:00:00"
}


# Jour 2 - matinée

# creme fraiche 40%
# creme-fraiche 40 %
# -> [crem, frai, 40%, laiteri]

# pipelines

POST test/_bulk
{"index" : {"_id": "12345", "pipeline" : "ma-pipeline"}}
{"name" :"alice"}

## 
POST _ingest/pipeline/_simulate
{
  "docs": [
    {
      "_source": {
        "message": "hello 1234 1.1.1.1"
      }
    },
    {
      "_source": {
        "message": "TEST 1234"
      }
    }
  ],
  "pipeline": {
    "description": "Cette pipeline blablabla",
    "processors": [
      {
        "set": {
          "field": "tag",
          "value": "log"
        }
      },
      {
        "grok": {
          "field": "message",
          "patterns": [
            "%{WORD:my-word}%{SPACE}%{INT:my-number}%{SPACE}%{IP:my-ip}",
            "%{WORD:my-word}%{SPACE}%{INT:my-number}"
          ]
        }
      },
      {
        "geoip": {
          "field": "my-ip",
          "if": "ctx.containsKey(\"my-ip\")"
        }
      },
      {
        "convert" : {
          "field" : "my-number",
          "type" : "integer"
        }
      },
      {
        "script" : {
          "source" : """
            ctx['my-number-2'] = ctx['my-number'] * 24;
            """
        }
      }
    ]
  }
}





POST _ingest/pipeline/_simulate
{
  "docs": [
    {
      "_source": {
        "message": "Alice;23;dev"
      }
    }
  ],
  "pipeline": {
    "description": "Cette pipeline blablabla",
    "processors": [
      {
        "csv": {
          "field": "message",
          "separator" : ";",
          "target_fields": [
            "user", "age", "emploi"
          ]
        }
      }
    ]
  }
}


# TP3 : pipelines

## 1. Ecriture de la pipeline

POST _ingest/pipeline/_simulate
{
  "docs": [
    {
      "_source": {
        "message": "2017-03-21T12:10:00+01:00;0087784009;Perpignan;76.0;11.0"
      }
    },
    {
      "_source": {
        "message": "2017-03-21T12:34:00+01:00;0087582825;Saint-Macaire;21.0;0.0"
      }
    },
    {
      "_source": {
        "message": ";0087582825;Saint-Macaire;21.0;0.0"
      }
    },
    {
      "_source": {
        "message": "2017-03-21T12:34:00+01:00;0087582825;Saint-Macaire;;"
      }
    },
    {
      "_source": {
        "message": "2017-03-21T12:34:00+01:00;0087582825;Saint-Macaire;0.0;0.0"
      }
    }
  ],
  "pipeline": {
    "processors": [
      {
        "csv" : {
          "field" : "message",
          "separator": ";",
          "target_fields": [
            "@timestamp", "CodeGare", "Gare", "Observations", "Problemes"
          ]
        }
      },
      {
        "drop" : {
          "if": """
            !ctx.containsKey('@timestamp') ||
            !ctx.containsKey('Observations') ||
            !ctx.containsKey('Problemes')
            """
        }
      },
      {
        "convert" : {
          "field" : "Observations",
          "type" : "float"
        }
      },
      {
        "convert" : {
          "field" : "Problemes",
          "type" : "float"
        }
      },
      {
        "drop": {
          "if" : "ctx['Observations'] <= 0 || ctx['Problemes'] < 0"
        }
      },
      {
        "script": {
          "source" : """
            ctx['TauxConformite'] = 100.0 * (1.0 - ctx['Problemes'] / ctx['Observations']);

            ctx['Problemes'] = (long) ctx['Problemes'];
            ctx['Observations'] = (long) ctx['Observations'];
            """
        }
      },
      {
        "remove": {
          "field": "message"
        }
      }
    ]
  }
}

PUT _ingest/pipeline/sncf-pipeline
{
  "description": "Parsing des données de non conformité",
  "processors": [
    {
      "csv": {
        "field": "message",
        "separator": ";",
        "target_fields": [
          "@timestamp",
          "CodeGare",
          "Gare",
          "Observations",
          "Problemes"
        ]
      }
    },
    {
      "drop": {
        "if": """
            !ctx.containsKey('@timestamp') ||
            !ctx.containsKey('Observations') ||
            !ctx.containsKey('Problemes')
            """
      }
    },
    {
      "convert": {
        "field": "Observations",
        "type": "float"
      }
    },
    {
      "convert": {
        "field": "Problemes",
        "type": "float"
      }
    },
    {
      "drop": {
        "if": "ctx['Observations'] <= 0 || ctx['Problemes'] < 0"
      }
    },
    {
      "script": {
        "source": """
            ctx['TauxConformite'] = 100.0 * (1.0 - ctx['Problemes'] / ctx['Observations']);

            ctx['Problemes'] = (long) ctx['Problemes'];
            ctx['Observations'] = (long) ctx['Observations'];
            """
      }
    },
    {
      "remove": {
        "field": "message"
      }
    }
  ]
}

## 2. Préparation de l'index et des runtime fields
DELETE sncf
PUT sncf
{
  "mappings": {
    "dynamic" : false,
    "properties": {
      "@timestamp" : {
        "type" : "date"
      },
      "CodeGare" : {
        "type" : "keyword",
        "index" : false
      },
      "Observations" : {
        "type" : "unsigned_long"
      },
      "Problemes" : {
        "type" : "unsigned_long"
      },
      "Gare" : {
        "type" : "keyword"
      },
      "TauxConformite" : {
        "type" : "float"
      }
    }
  }
}

GET _cat/indices/sncf?v&h=store.size

PUT sncf/_mapping
{
  "runtime": {
    "hour_of_day": {
      "type": "double",
      "script": {
        "source": """
        if(doc['@timestamp'].size()!=0 )
          emit(doc['@timestamp'].value.getHour());
        else
          emit(0);
        """
      }
    },
    "day_of_week": {
      "type": "keyword",
      "script": {
        "source": """
        if(doc['@timestamp'].size() == 0)
          emit('NA');
        else
        emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT));
        """
      }
    }
  }
}

## 3. configuration logstash

## 4. Envoi des données, vérification
GET sncf/_search
GET sncf/_count

## 5. Dashboard kibana

# Jour 3 : matinée

# TP3 : pipelines

## 1. Ecriture de la pipeline

POST _ingest/pipeline/_simulate
{
  "docs": [
    {
      "_source": {
        "message": "2017-03-21T12:10:00+01:00;0087784009;Perpignan;76.0;11.0"
      }
    },
    {
      "_source": {
        "message": "2017-03-21T12:34:00+01:00;0087582825;Saint-Macaire;21.0;0.0"
      }
    },
    {
      "_source": {
        "message": ";0087582825;Saint-Macaire;21.0;0.0"
      }
    },
    {
      "_source": {
        "message": "2017-03-21T12:34:00+01:00;0087582825;Saint-Macaire;;"
      }
    },
    {
      "_source": {
        "message": "2017-03-21T12:34:00+01:00;0087582825;Saint-Macaire;0.0;0.0"
      }
    }
  ],
  "pipeline": {
    "processors": [
      {
        "csv" : {
          "field" : "message",
          "separator": ";",
          "target_fields": [
            "@timestamp", "CodeGare", "Gare", "Observations", "Problemes"
          ]
        }
      },
      {
        "drop" : {
          "if": """
            !ctx.containsKey('@timestamp') ||
            !ctx.containsKey('Observations') ||
            !ctx.containsKey('Problemes')
            """
        }
      },
      {
        "convert" : {
          "field" : "Observations",
          "type" : "float"
        }
      },
      {
        "convert" : {
          "field" : "Problemes",
          "type" : "float"
        }
      },
      {
        "drop": {
          "if" : "ctx['Observations'] <= 0 || ctx['Problemes'] < 0"
        }
      },
      {
        "script": {
          "source" : """
            ctx['TauxConformite'] = 100.0 * (1.0 - ctx['Problemes'] / ctx['Observations']);

            ctx['Problemes'] = (long) ctx['Problemes'];
            ctx['Observations'] = (long) ctx['Observations'];
            """
        }
      },
      {
        "remove": {
          "field": "message"
        }
      }
    ]
  }
}

PUT _ingest/pipeline/sncf-pipeline
{
  "description": "Parsing des données de non conformité",
  "processors": [
    {
      "csv": {
        "field": "message",
        "separator": ";",
        "target_fields": [
          "@timestamp",
          "CodeGare",
          "Gare",
          "Observations",
          "Problemes"
        ]
      }
    },
    {
      "drop": {
        "if": """
            !ctx.containsKey('@timestamp') ||
            !ctx.containsKey('Observations') ||
            !ctx.containsKey('Problemes')
            """
      }
    },
    {
      "convert": {
        "field": "Observations",
        "type": "float"
      }
    },
    {
      "convert": {
        "field": "Problemes",
        "type": "float"
      }
    },
    {
      "drop": {
        "if": "ctx['Observations'] <= 0 || ctx['Problemes'] < 0"
      }
    },
    {
      "script": {
        "source": """
            ctx['TauxConformite'] = 100.0 * (1.0 - ctx['Problemes'] / ctx['Observations']);

            ctx['Problemes'] = (long) ctx['Problemes'];
            ctx['Observations'] = (long) ctx['Observations'];
            """
      }
    },
    {
      "remove": {
        "field": "message"
      }
    }
  ]
}

## 2. Préparation de l'index et des runtime fields
DELETE sncf
PUT sncf
{
  "mappings": {
    "dynamic" : false,
    "properties": {
      "@timestamp" : {
        "type" : "date"
      },
      "CodeGare" : {
        "type" : "keyword",
        "index" : false
      },
      "Observations" : {
        "type" : "unsigned_long"
      },
      "Problemes" : {
        "type" : "unsigned_long"
      },
      "Gare" : {
        "type" : "keyword"
      },
      "TauxConformite" : {
        "type" : "float"
      }
    }
  }
}

GET _cat/indices/sncf?v&h=store.size

PUT sncf/_mapping
{
  "runtime": {
    "hour_of_day": {
      "type": "double",
      "script": {
        "source": """
        if(doc['@timestamp'].size()!=0 )
          emit(doc['@timestamp'].value.getHour());
        else
          emit(0);
        """
      }
    },
    "day_of_week": {
      "type": "keyword",
      "script": {
        "source": """
        if(doc['@timestamp'].size() == 0)
          emit('NA');
        else
        emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT));
        """
      }
    }
  }
}

## 3. configuration logstash

## 4. Envoi des données, vérification
GET sncf/_search
GET sncf/_count
{
    "query": {
        "exists": {
            "field" : "@timestamp"
        }
    }
}


# data stream
GET filebeat-9.2.1
GET _data_stream

GET filebeat-9.2.1/_search


GET filebeat-*,fruits,bank/_search


GET _ingest/pipeline/*nginx*




## 5. Dashboard kibana



PUT bank/_settings
{
  "number_of_replicas": 3
}

GET filebeat-9.2.1/_search?q=nginx

GET filebeat-9.2.1/_search
{
  "query": {
    "bool": {
      "filter" : [
        {
          "term": {
            "event.dataset": "nginx.access"
          }
        },
        { 
          "term": {
            "url.path": "/attack"
          }
        }
      ]
    }
  }
}

GET .monitoring-es-7-2025.11.26

GET _nodes?filter_path=nodes.*.name,nodes.*.version&format=yaml

# node name
# version elastic
# roles
# ip
# attributs customs
# heap size configurée

GET _cat/allocation?v&h=shards,disk.percent,node


PUT prenom
{
    "settings": {
        "number_of_replicas": 2,
        "index.number_of_shards": 3
    }
}

GET _ilm/policy/filebeat



POST filebeat-9.2.1/_rollover


GET _data_stream
PUT _data_stream/filebeat-9.2.1
DELETE _data_stream/filebeat-9.2.1


GET .ds-filebeat-9.2.1-2025.11.27-000001


GET _cat/shards?v

GET _ilm/policy/filebeat

POST _aliases
{
  "actions": [
    {
      "add": {
        "index": "bank",
        "alias": "production"
      }
    }
  ]
}

GET production/_count


POST _aliases
{
  "actions": [
    {
      "remove": {
        "index": "bank",
        "alias": "production"
      }
    },
    {
      "add": {
        "index": "bank2",
        "alias": "production"
      }
    }
  ]
}


POST _aliases
{
  "actions": [
    {
      "add": {
        "index": "filebeat-9.2.1",
        "alias": "nginx-logs",
        "filter": {
          "term": {
            "event.dataset": "nginx.access"
          }
        }
      }
    }
  ]
}

GET nginx-logs/_count






# routing
DELETE recettes-cuisine
PUT recettes-cuisine
{
    "settings": {
        "index.number_of_shards": 10,
        "number_of_replicas": 0
    }
}

GET _cat/shards/recettes-cuisine?v&h=shard,docs
GET _refresh
POST recettes-cuisine/_doc?refresh=true&routing=bob
{
    "title" : "mousse au chocolat"
}

# numero shard = _id | _routing (si précisé) % 10

GET recettes-cuisine/_count?routing=bob,alice

POST _aliases
{
    "actions": [
      {
        "add": {
          "index": "recettes-cuisine",
          "alias": "recette-alice",
          "routing": "alice"
        }
      }
    ]
}



```
